---
title: "Turtle Dive Behavior"
author: "Vic Quennessen"
date: "5/22/2022"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, load libraries}
# load libraries
library(lubridate)
library(dplyr)
```

```{r, turtle ID}
# identity of turtle
ID <- 41589
```

```{r, import data}
# make sure to change this so you import the data from your own working directory

# import GPS data, filter by turtle
GPS <- read.csv('~/Projects/iliketurtles/data/MERGED_centroid.csv', 
                header = TRUE)
GPS_turtle <- GPS %>% filter(Name == ID)

# import data
behavior <- read.csv(paste('~/Projects/iliketurtles/data/', ID, '-Behavior.csv', 
                           sep = ''), header = TRUE)

# make date objects
behavior$Start <- as.POSIXlt(behavior$Start, format = "%H:%M:%S %d-%b-%Y")
behavior$End <- as.POSIXlt(behavior$End, format = "%H:%M:%S %d-%b-%Y")
GPS_turtle$Day_time <- as.POSIXlt(GPS_turtle$Day_time, 
                                  format = "%d/%m/%Y %H:%M")

# extract only dives from behavior
dives <- behavior %>% filter(What == 'Dive')

# extract only surface time from behavior
surfaces <- behavior %>% filter(What == 'Surface')
```

\newpage

2a. average dive duration

```{r}
# create start time, end time, and total time interval column in dives DF
dives$Interval_min <- as.numeric(dives$End - dives$Start) / 60

# average dive interval, in minutes
(avg_dive_interval_min <- mean(dives$Interval_min))
```

2b. average dive range

```{r}
# add dive range column
dives$Range <- max(dives$DepthMax, dives$DepthMin)

# average range
(avg_dive_range <- mean(dives$Range))
```

\newpage


1. How many dives (dives can start in one interval and finish in the next, so in this case we should break into fractions - how much of the dive occurred in one segment and what fraction belongs to the next interval); and 3. sum of dive interval 

```{r}
# add Dives and Dive_time column to GPS_turtle
GPS_turtle$Dives <- 0
GPS_turtle$Dive_time_min <- 0

# for each interval, count number of dives
for (gps in 1:(nrow(GPS_turtle) - 1)) {
  
  # how many dives are fully inside the interval
  whole_dives <- which(dives$Start > GPS_turtle$Day_time[gps] & 
                         dives$End < GPS_turtle$Day_time[gps + 1])
  
  # how many dives start inside the interval but don't end
  partial_dives <- which((dives$Start < GPS_turtle$Day_time[gps] & 
                            dives$End > GPS_turtle$Day_time[gps] &
                            dives$End < GPS_turtle$Day_time[gps + 1]) |
                           (dives$Start < GPS_turtle$Day_time[gps] &
                              dives$End > GPS_turtle$Day_time[gps + 1]) |
                           (dives$Start > GPS_turtle$Day_time[gps] &
                              dives$Start < GPS_turtle$Day_time[gps + 1] &
                              dives$End > GPS_turtle$Day_time[gps + 1]))
  
  if (length(partial_dives) > 0) {
    
    # initialize fraction vector
    fraction <- rep(NA, length(partial_dives))
    partial_time <- rep(NA, length(partial_dives))
    
    for (pd in 1:length(partial_dives)) {
      
      # fraction of dives in interval
      start_dive <- max(which(GPS_turtle$Day_time < dives$Start[partial_dives[pd]]))
      end_dive <- min(which(GPS_turtle$Day_time > dives$End[partial_dives[pd]]))
      interval_length <- end_dive - start_dive
      fraction[pd] <- 1 / interval_length
      
      # time of dives in interval - minutes
      GPS_interval <- interval(GPS_turtle$Day_time[gps], 
                                   GPS_turtle$Day_time[gps + 1])
      dive_interval <- interval(dives$Start[partial_dives[pd]], 
                                    dives$End[partial_dives[pd]])
      seconds_overlap <- second(as.period(intersect(GPS_interval, 
                                                    dive_interval), "seconds"))
      partial_time[pd] <- seconds_overlap / 60
      
    }
    
    # add dives to GPS dataframe
    GPS_turtle$Dives[gps] <- length(whole_dives) + sum(fraction)
    
    # add dive times to GPS dataframe
    GPS_turtle$Dive_time_min[gps] <- 
      sum(dives$Interval_sec[whole_dives]) + sum(partial_time)
    
  } else {
    
    # add dives to GPS dataframe
    GPS_turtle$Dives[gps] <- length(whole_dives)
    
    # add dive times to GPS dataframe
    GPS_turtle$Dive_time_min[gps] <- sum(dives$Interval_sec[whole_dives])
    
  }
  
}
```

\newpage

4. what percentage of each dive shape

```{r}
prop.table(table(dives$Shape))
```

\newpage

5. surfaces per GPS interval and 7. sum of surface interval 

```{r}
# add surfaces column to GPS_turtle
GPS_turtle$Surfaces <- 0
GPS_turtle$Surface_time_min <- 0

# for each interval, count number of dives
for (gps in 1:(nrow(GPS_turtle) - 1)) {
  
  # how many dives are fully inside the interval
  whole_surfaces <- which(surfaces$Start > GPS_turtle$Day_time[gps] & 
                         surfaces$End < GPS_turtle$Day_time[gps + 1])
  
  # how many dives start inside the interval but don't end
  partial_surfaces <- which((surfaces$Start < GPS_turtle$Day_time[gps] & 
                            surfaces$End > GPS_turtle$Day_time[gps] &
                            surfaces$End < GPS_turtle$Day_time[gps + 1]) |
                           (surfaces$Start < GPS_turtle$Day_time[gps] &
                              surfaces$End > GPS_turtle$Day_time[gps + 1]) |
                           (surfaces$Start > GPS_turtle$Day_time[gps] &
                              surfaces$Start < GPS_turtle$Day_time[gps + 1] &
                              surfaces$End > GPS_turtle$Day_time[gps + 1]))
  
  if (length(partial_surfaces) > 0) {
    
    # initialize fraction vector
    fraction_s <- rep(NA, length(partial_surfaces))
    partial_time_s <- rep(NA, length(partial_surfaces))
    
    for (ps in 1:length(partial_surfaces)) {
      
      # fraction of dives in interval
      start_surface <- max(which(GPS_turtle$Day_time < dives$Start[partial_surfaces[ps]]))
      end_surface <- min(which(GPS_turtle$Day_time > dives$End[partial_surfaces[ps]]))
      interval_length <- end_surface - start_surface
      fraction_s[ps] <- 1 / interval_length
      
      # time of dives in interval - minutes
      GPS_interval <- interval(GPS_turtle$Day_time[gps], 
                                   GPS_turtle$Day_time[gps + 1])
      surface_interval <- interval(dives$Start[partial_surfaces[ps]], 
                                    dives$End[partial_surfaces[ps]])
      seconds_overlap_s <- second(as.period(intersect(GPS_interval, 
                                                    surface_interval), "seconds"))
      partial_time_s[ps] <- seconds_overlap_s / 60
      
    }
    
    # add dives to GPS dataframe
    GPS_turtle$Surfaces[gps] <- length(whole_surfaces) + sum(fraction_s)
    
    # add dive times to GPS dataframe
    GPS_turtle$Surface_time_min[gps] <- 
      sum(surfaces$Interval_sec[whole_surfaces]) + sum(partial_time_s)
    
  } else {
    
    # add dives to GPS dataframe
    GPS_turtle$Surfaces[gps] <- length(whole_surfaces)
    
    # add dive times to GPS dataframe
    GPS_turtle$Surface_time_min[gps] <- sum(dives$Interval_sec[whole_surfaces])
    
  }
  
}
```


\newpage

6a. average surface duration

```{r}
# calculate intervals in seconds and minutes
surfaces$Interval_sec <- as.numeric(surfaces$End - surfaces$Start)
surfaces$Interval_min <- surfaces$Interval_sec / 60

# average dive interval, in seconds
avg_surface_interval_sec <- mean(surfaces$Interval_sec)

# average dive interval, in minutes
(avg_surface_interval_min <- mean(surfaces$Interval_min))
```

6b. average surface range

```{r}

```

\newpage 

8. average depth

```{r}
# create depth column that's the average between DepthMin and DepthMax
dives$Depth <- (dives$DepthMin + dives$DepthMax) / 2

# average depth
(avg_depth <- mean(dives$Depth))
```